// Package proxy sets the proxy configuration for the system.
package proxy

import (
	"context"
	"os"
	"path/filepath"

	log "github.com/sirupsen/logrus"
	"github.com/ubuntu/decorate"
)

// Proxy represents a proxy manager.
type Proxy struct {
	settings      []setting
	envConfigPath string
}

// DryRun is a context key to indicate that we should not apply the proxy
// settings. It is intended to be used in tests only.
var DryRun = struct{}{}

type options struct {
	root          string
	envConfigPath string
}
type option func(*options)

const confHeader = "### This file was generated by ubuntu-proxy-manager - manual changes will be overwritten"

const (
	// defaultEnvConfigPath is the relative path to the system environment configuration file.
	defaultEnvConfigPath = "etc/environment.d/99ubuntu-proxy-manager.conf"
)

// New returns a new instance of a proxy manager.
func New(ctx context.Context, args ...option) (p *Proxy, err error) {
	defer decorate.OnError(&err, "couldn't create proxy manager")

	// Set default options
	opts := options{
		root:          "/",
		envConfigPath: defaultEnvConfigPath,
	}
	// Apply given options
	for _, f := range args {
		f(&opts)
	}

	return &Proxy{
		envConfigPath: filepath.Join(opts.root, opts.envConfigPath),
	}, nil
}

// Apply applies the proxy configuration to the system.
func (p Proxy) Apply(ctx context.Context, http, https, ftp, socks, no, mode string) (err error) {
	defer decorate.OnError(&err, "couldn't apply proxy configuration")

	if ctx.Value(DryRun) == true {
		log.Infof("Skipping proxy application in dry-run mode")
		return nil
	}
	log.Infof("Applying proxy configuration")

	p.settings, err = newSettings(http, https, ftp, socks, no)
	if err != nil {
		return err
	}

	return p.applyToEnvironment()
}

// previousConfig returns the previous configuration if it exists. No error is
// returned if the file doesn't exist, but other errors are.
func previousConfig(path string) (content string, err error) {
	defer decorate.OnError(&err, "couldn't read previous configuration")

	// #nosec G304 - path not controllable by user
	prevConf, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}

	return string(prevConf), nil
}
