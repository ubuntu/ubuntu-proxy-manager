// Package proxy sets the proxy configuration for the system.
package proxy

import (
	"context"
	"os"
	"path/filepath"

	log "github.com/sirupsen/logrus"
	"github.com/ubuntu/decorate"
)

// Proxy represents a proxy manager.
type Proxy struct {
	settings      []setting
	envConfigPath string
	aptConfigPath string
}

type options struct {
	root          string
	envConfigPath string
	aptConfigPath string
}
type option func(*options)

const confHeader = "### This file was generated by ubuntu-proxy-manager - manual changes will be overwritten"

const (
	// defaultEnvConfigPath is the relative path to the system environment configuration file.
	defaultEnvConfigPath = "etc/environment.d/99ubuntu-proxy-manager.conf"

	// defaultAptConfigPath is the relative path to the APT proxy configuration file.
	defaultAptConfigPath = "etc/apt/apt.conf.d/99ubuntu-proxy-manager"
)

// New returns a new instance of a proxy manager.
func New(ctx context.Context, args ...option) *Proxy {
	// Set default options
	opts := options{
		root:          "/",
		envConfigPath: defaultEnvConfigPath,
		aptConfigPath: defaultAptConfigPath,
	}
	// Apply given options
	for _, f := range args {
		f(&opts)
	}

	return &Proxy{
		envConfigPath: filepath.Join(opts.root, opts.envConfigPath),
		aptConfigPath: filepath.Join(opts.root, opts.aptConfigPath),
	}
}

// Apply applies the proxy configuration to the system.
func (p Proxy) Apply(ctx context.Context, http, https, ftp, socks, no, mode string) (err error) {
	defer decorate.OnError(&err, "couldn't apply proxy configuration")

	log.Infof("Applying proxy configuration")

	p.settings, err = newSettings(http, https, ftp, socks, no)
	if err != nil {
		return err
	}

	if err := p.applyToEnvironment(); err != nil {
		return err
	}
	if err := p.applyToApt(); err != nil {
		return err
	}
	return nil
}

// previousConfig returns the previous configuration if it exists. No error is
// returned if the file doesn't exist, but other errors are.
func previousConfig(path string) (content string, err error) {
	defer decorate.OnError(&err, "couldn't read previous configuration")

	// #nosec G304 - path not controllable by user
	prevConf, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}

	return string(prevConf), nil
}
